
Architecture technique du live chat : 
- Backend : Django + Channels (WebSockets) pour gérer les messages.
- Frontend : JavaScript pour la communication avec le serveur et l'interface utilisateur.
+ Framwork bootstrap

Eléments nécessaires pour la connexion/communication et le stockage des données
- Authentification JWT.
- Gestion des WebSockets.
- Base de données (si nécessaire pour le stockage des messages ou des relations comme le blocage).

1. Points à prévoir pour le backend : 
Websocket :
    - Créer un ChatConsumer dans consumers.py pour gérer les connexions des utilisateurs.
    - Les utilisateurs doivent rejoindre un groupe (par exemple, un groupe par discussion privée ou publique).
    - Les messages doivent être diffusés en temps réel aux membres du groupe.
Authentification : 
    - Utiliser les tokens JWT pour identifier les utilisateurs connectés.
    - Vérifier l'identité des utilisateurs à chaque connexion WebSocket.
Blocage et gestion des relations : 
    - Ajouter une logique pour gérer le blocage des utilisateurs :
        > en mémoire
        > via une base de données
Stockage des messages :
    ! Décider si les messages doivent être stockés dans la bdd. !


2. Actions à mettre en place (à compléter) :
- Créer un ChatConsumer :
    > Initialiser un groupe WebSocket pour chaque discussion.
    > Gérer l'envoi et la réception des messages.

- Vérifier l'identité des users à chaque connexion.

- Configurer les routes WebSocket dans routing.py :
    > Ajouter un chemin pour le chat, par exemple : ws/chat/.

- Ajouter des modèles :
    > Message : Contient l'expéditeur, le destinataire, et le contenu.
    > BlockedUser : Gère les relations de blocage.


FRONTEND
1. Points à prévoir pour le frontend : 
- Connexion WebSocket :
    > Établir une connexion WebSocket au serveur dès que l'utilisateur accède au chat.
    > Envoyer et recevoir des messages via cette connexion.

- Affichage des messages :
    > Afficher les messages reçus en temps réel.
    > Add une zone de texte pour taper et envoyer des messages.

- Gestion des commandes :
    > Gérer les actions spécifiques, comme bloquer un utilisateur ou envoyer une invitation à jouer.

2. Actions à mettre en place (à compléter) :
- Ajouter une connexion WebSocket :
    > Établir une connexion avec l’URL du serveur WebSocket (par exemple : ws://localhost:8000/ws/chat/).
    > Envoyer des messages sous forme de JSON ({ "action": "send_message", "content": "Bonjour !" }).

- Créer une interface simple (via bootstrap):
    > Zone d’affichage des messages.
    > Zone de saisie de texte + bouton d’envoi.


UTILISATION DES ELEMENTS EXISTANTS : 
- Authentification JWT :
    > Les utilisateurs doivent inclure leur token JWT dans la requête WebSocket (par exemple, via les paramètres d’URL : ws://localhost:8000/ws/chat/?token=<JWT>).
    > Le backend vérifiera le token pour identifier l'utilisateur.

- Gestion des WebSockets :
    > Réutiliser la configuration de Django Channels et ajouter une nouvelle route WebSocket.

- Intégration au projet existant :
    > L’interface du chat sera accessible depuis le frontend existant.
    > Les notifications de tournoi et invitations seront intégrées après la base du chat.


SPRINTS SUIVANTS : 

- Sprint 2 : Envoi et réception des messages
    > Implémenter la base du chat en temps réel.
    > Ajouter un WebSocket pour échanger les messages.

Sprint 3 : Blocage d’utilisateurs
    > Ajouter une gestion des utilisateurs bloqués.

Sprint 4 : Invitations à jouer
    > Permettre d’envoyer une invitation via le chat.

Sprint 5 : Notifications de tournoi
    > Intégrer les notifications dans le chat.



ETAPES - SPRINT 1 : 
1. Configurer le backend pour gérer les WebSockets et les messages.
2. Ajouter une route WebSocket pour le live chat.
3. Créer un consumer qui gère les connexions, envoie et réceptionne des messages.
4. Configurer le frontend pour se connecter au WebSocket et afficher/écrire des messages.